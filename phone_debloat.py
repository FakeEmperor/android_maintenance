# Debloat your phone and remove analytics, tracking, AdWare and potential attack surfaces
import click
import re
import os
from pathlib import Path
from typing import List
import subprocess
import logging

logger = logging.getLogger(__name__)


@click.group()
def main():
    pass


@main.command("remove")
@click.argument("blacklist", required=False, default="blacklist.txt")
@click.option("--uninstall", type=bool, is_flag=True, required=False, default=False)
@click.option("--user", type=int, default=0)
@click.option("--revert", type=bool, is_flag=True, default=False)
def remove(blacklist: str, uninstall: bool, user: int, revert: bool):
    """
    Remove or disable packages that are in the blacklist.
    """
    debloat_list_path = Path(blacklist)
    click.secho(f"Reading blacklist @ {debloat_list_path}...", fg="green")
    debloat_packages = read_packages(debloat_list_path.read_text())
    debloat_commands_path = Path("debloat_autogen.sh")
    if revert:
        command = 'enable' if not uninstall else 'install-existing'
    else:
        command = 'disable-user' if not uninstall else 'uninstall'
    click.secho(f"Found {len(debloat_packages)} entries in debloat list...", fg="green")
    click.secho(f"Writing at {debloat_commands_path}. Mode: {command}, user: {user}", fg="green")
    with debloat_commands_path.open("w") as f:
        f.write(f"#!/usr/bin/bash\n"
                f"# THIS IS AUTOGENERATED, DO NOT EDIT!\n"
                f"set -e\n"
                f"total={len(debloat_packages)}\n"
                f"finished=0\n"
                f"failed=\"\"\n")
        for idx, pkg in enumerate(debloat_packages, 1):
            f.write(f"apk={pkg}; echo -e '\\e[32m[{idx}/{len(debloat_packages)}]"
                    f"{'Disabling' if not uninstall else 'Deleting'} \\e[34m{pkg}...\\e[0m'\n"
                    f"adb shell 'pm {command} --user {user} {pkg}' && finished=$((finished+1)) || "
                    f"{{ echo -e '\\e[31mFailed!\\e[0m' && failed=\"$failed $apk\"; }}\n")
        f.write(f"echo -e '\\e[0mSuccessfully deleted \\e[33m ' \"$finished\" '\\e[0m out of ' \"\\e[33m$total\\e[0m packages\\e[0m\"\n")
        f.write(f"failed=($failed); echo -e \"\\e[0mFailed to {command}:\"; printf '  - %s\\n' \"${{failed[@]}}\"")


def read_packages(packages_contents: str) -> List[str]:
    regex = re.compile(r'^(?P<pkg>.*?)\s*(#.*)?$')
    debloat_list = (line for line in packages_contents.splitlines() if line and not line.startswith('#'))
    debloat_packages = set()
    for line in debloat_list:
        pkg = regex.match(line).group("pkg")
        if not pkg:
            raise ValueError(f"Could not find the package in {line}")
        debloat_packages.add(pkg)
    return sorted(debloat_packages)


def list_packages(user: int, disabled: bool = True, enabled: bool = True, system: bool = True) -> List[str]:
    command = ["adb", "shell", f"pm list packages --user {user} -f"]
    flags = []
    if disabled and enabled and system:
        flags = ["-a"]
    else:
      if disabled and not enabled:
        flags = ["-d"]
      elif enabled and not disabled:
        flags = ["-e"]
      if system:
          flags += ["s"]
    command[-1] += " " + " ".join(flags)
    try:
        adb_output: str = subprocess.check_output(command, stderr=subprocess.STDOUT)
    except subprocess.CalledProcessError as e:
        logger.error(f"Failed to obtain data from adb [e.returncode]:\n{e.output.decode()}", exc_info=True)
        raise
    packages = []
    for line in adb_output.decode().splitlines():
        match = re.match(r'^.*=(.*)$', line)
        if match and match.group(1):
            packages.append(match.group(1))
    packages.sort()
    return packages


@main.command("list-packages")
@click.argument("destination", type=str)
@click.option("--user", type=int, default=0)
@click.option("--system/--no-system", default=True)
@click.option("--disabled/--no-disabled", default=True)
def list_packages_command(destination: str, user: int, system: bool, disabled: bool):
    """
    Lists packages present on the device
    """
    data = "\n".join(list_packages(user=user, system=system, disabled=disabled))
    if destination != "-":
        destination = Path(destination)
        destination.write_text(data, encoding='utf-8')
    else:
        click.echo(data)


@main.command("revoke")
@click.option("--user", type=int, default=0)
@click.option("--only-enabled", is_flag=True, type=bool, default=False)
@click.option("--apks", type=str, required=False, default=None)
@click.option("--permissions-path", type=str, required=False, default="permissions.txt")
def revoke_all(user: int, only_enabled: bool, apks: str, permissions_path: str):
    """
    Revoke all permissions from applications.
    You can target only enabled applications or all of them.
    """
    permissions_path = Path(permissions_path)
    apks_path = Path(f"./apks.temp.uid{user}.txt") if not apks else Path(apks)
    revoke_all_path = Path("./revoke_all_autogen.sh")
    click.secho(f"Reading available permissions @ {permissions_path}...", fg="green")
    permissions = set()
    for line in permissions_path.read_text().splitlines():
        permission = re.match(r'\s+permission:(\S+)\s*', line)
        if permission:
            permission = permission.group(1)
            permissions.add(permission)
            click.secho(f"Found permission: {permission}", fg="blue")
    click.secho(f"Found {len(permissions)} unique permissions on the phone...", fg="green")

    apks = list_packages(user=user, disabled=not only_enabled) if not apks else read_packages(apks_path.read_text())
    apks_path.write_text('\n'.join(apks))
    click.secho(f"Found {len(apks)} APKs to revoke permissions for...", fg="green")
    with revoke_all_path.open("w") as f:
        f.write(f"#!/usr/bin/bash\n"
                f"# THIS IS AUTOGENERATED, DO NOT EDIT!"
                f"set -e\n"
                f"total={len(apks)}\n"
                f"finished=0\n"
                f"failed=\"\"\n")
        for idx, apk in enumerate(apks, 1):
            permission_revoke = ' ; '.join([
                f'adb shell \'pm revoke --user {user} {apk} {p} > /dev/null 2>&1\' && permissions=$((permissions+1)) || true'
                for p in permissions
            ])
            f.write(f"apk=\"{apk}\"; echo -e '\\e[32m[{idx}/{len(apks)}] Disabling \\e[34m{apk}...\\e[0m'\n")
            f.write(f"permissions=0;\n")
            f.write(f"{permission_revoke} && finished=$((finished+1)) && "
                    f"echo -e '\\e[32mSuccess' \"$permissions\" ='!\\e[0m' ||  "
                    f"{{ echo -e '\\e[31mFailed!\\e[0m' && failed=\"$failed $apk\"; }}\n")
        f.write(f"echo -e '\\e[0mSuccessfully revoked from permissions"
                f"\\e[33m ' \"$finished\" '\\e[0m out of ' \"\\e[33m$total\\e[0m packages\\e[0m\"\n")
        f.write(f"failed=($failed); echo -e \"\\e[0mFailed to revoke from:\"; printf '  - %s\\n' \"${{failed[@]}}\"")


if __name__ == "__main__":
    main()
